<?xml version="1.0" encoding="utf-8" standalone="yes"?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
  <channel>
    <title>Data Structure on zylhorse blog</title>
    <link>https://zylhorse.github.io/categories/data-structure/</link>
    <description>Recent content in Data Structure on zylhorse blog</description>
    <generator>Hugo -- gohugo.io</generator>
    <language>zh-CN</language>
    <lastBuildDate>Thu, 28 Oct 2021 00:00:00 +0000</lastBuildDate><atom:link href="https://zylhorse.github.io/categories/data-structure/index.xml" rel="self" type="application/rss+xml" />
    <item>
      <title>Protocol Buffers - FAQ</title>
      <link>https://zylhorse.github.io/blog/data-structure/protocol-buffers/faq/</link>
      <pubDate>Thu, 28 Oct 2021 00:00:00 +0000</pubDate>
      
      <guid>https://zylhorse.github.io/blog/data-structure/protocol-buffers/faq/</guid>
      <description>本文讨论一些Protocol Buffers 开源项目的一些常见问题。 如果你有一些问题，这里没有回答，请加入讨论组并提问。
普通问题 为什么发布Protocol Buffers？
有以下几个原因:
 Protocol Buffers 在Google中几乎被每个人使用。我们有许多想要开源发布的项目在使用protocol buffers, 因此我们需要首先发布protocol bufeers。事实上，一些技术已经可以在开源项目中找到 - 如果你深入Google AppEngine 代码，你会发现它们。 我们愿意提供接收protocol buffers和XML的公共API, 因为这非常高效，而且我们只是把XML转换成protocol buffers。 我们认为Google之外的人会发现protocol buffers会很有用 将protocol buffers变成我们乐意发布的形式是有趣20%的项目。  为什么首次发布版本2？版本1发生了什么？
protocol buffers的初始版本(亦名Proto1)最早在2001年在Google内开始开发，经过多年的发展，当有人需要并且愿意自己做，就会萌生出新的特性。 就像任何以这种方式创造出来的东西一样，它有点混乱。我们得出的结论是，按照现在的样子发布代码是不可行的。
版本2(Proto2)是一个完全重写的版本，尽管它保留了大部分的设计并使用了许多来自Proto1的实现思想。添加了一些功能，删除了一些。 然而，最重要的是，代码被清理干净，并且没有任何依赖于尚未开放源码的Google库。
为什么命名为&amp;quot;Protocol Buffers&amp;quot;？
这个名称源于该格式的早期，那时还没有协议缓冲区编译器来为我们生成类。 当时，有一个名为ProtocolBuffer的类，它实际上充当了单个方法的缓冲区。 用户可以通过调用AddValue(tag, value)等方法将tag/value对分别添加到这个缓冲区。 原始字节被存储在一个缓冲区中，一旦消息被构造好，这个缓冲区就可以被写出来。
从那时起，名称中的“buffers”部分就失去了意义，但它仍然是我们使用的名称。今天，人们通常使用术语“protocol message”来指抽象意义上的message， “protocol buffer”指消息的序列化副本，“protocol message object”指表示已解析消息的内存对象。
Google还有Protocol Buffers的任何专利吗？
Google目前没有关于Protocol Buffers的授权专利，我们很高兴解决人们可能有的关于协议缓冲区和专利的任何担忧。
技术类问题  Similar Technologies
 Protocol Buffers 和 XML 有什么不同?
答案见概述页
Protocol Buffers和ASN.1,COM,CORBA,Thrift,etc 有什么不同？
我们认为所有这些系统都有优点和缺点。Google内部依赖protocol buffers，并且它是我们成功的重要组成部分， 但是这并不意味着它是所有问题的理想解决方案。你应该在自己项目中评估以上每一个选项。
但是，值得注意的是，这些技术中有几种同时定义了交换格式和RPC(远程过程调用)协议。协议缓冲区只是一种交换格式。 它们可以很容易地用于RPC——实际上，它们对定义RPC services 的支持是有限的——但是它们没有绑定到任何一个RPC实现或协议。</description>
    </item>
    
    <item>
      <title>Protocol Buffers - Version 3指南</title>
      <link>https://zylhorse.github.io/blog/data-structure/protocol-buffers/guide/</link>
      <pubDate>Thu, 28 Oct 2021 00:00:00 +0000</pubDate>
      
      <guid>https://zylhorse.github.io/blog/data-structure/protocol-buffers/guide/</guid>
      <description>本指南描述如何使用Protocol Buffers语言来构建Protocol Buffers数据结构。 包括.proto文件语法以及如何从.proto文件生成数据访问类。
 所有示例指定语言为Go
[PB2] 表示pb version2 的指南
[PB3] 表示pb version3 的指南
 定义Message  Defining A Message Type
 首先看一个简单的例子。这里我们定义一个搜索请求的message格式，每条搜索请求包含查询字符串，整数页码和每页结果条数。
示例:
[PB2]syntax = &amp;quot;proto2&amp;quot;;message SearchRequest {required string query = 1;optional int32 page_number = 2;optional int32 result_per_page = 3;}[PB3]syntax = &amp;quot;proto3&amp;quot;;message SearchRequest {string query = 1;int32 page_number = 2;int32 result_per_page = 3;}SearchRequest 定义了三个字段, 每个字段包含：type name = filed number; (参考规范)</description>
    </item>
    
    <item>
      <title>Protocol Buffers - 技巧</title>
      <link>https://zylhorse.github.io/blog/data-structure/protocol-buffers/techniques/</link>
      <pubDate>Thu, 28 Oct 2021 00:00:00 +0000</pubDate>
      
      <guid>https://zylhorse.github.io/blog/data-structure/protocol-buffers/techniques/</guid>
      <description>本文描述处理protocol buffer的一些常用设计模式。你也可以发送设计和使用问题到Protocol Buffers 讨论组
流化多个Message  Streaming Multiple Messages
 如果你想要写多个message到单个文件或流中，由你确定跟踪一个message结束位置和下一个message开始的位置。protocol buffer格式不是自定义的， 因此protocol buffer解析器无法自行确定消息的结束位置。解决这个问题最简单的方法是在写message之前，先写message大小。 当你读入message时，先读大小，然后读取字节到一个单独的缓冲区，再从缓冲区解析。(如果你想要避免拷贝字节到一个独立的缓冲区， 请检查CodedInputStrem类(C++和Java中)，它可以告知将读取限制为特定的字节数)
大数据集  Large Data Sets
 protocol buffer不是为处理大型message而设计的。根据一般经验，如果每个处理的message都大于1M字节, 那么需要考虑替代方案。
这就是说，protocol buffer非常适合处理大型数据集中的单个message。通常，大型数据集实际上只是小块的集合，其中每小块可能是结构化的数据块。 尽管protocol buffer不能一次处理整个集合，使用protocol buffer来编码每块可以大大简化你的问题: 现在你只需要处理一组字节字符串，而不是一组结构。
protocol buffer不包含对大数据集的内置支持，因为不同的情况需要不同的解决方案。有些时候一个简单的记录列表就可以， 而其它时候你需要一个类似数据库的东西。每一种解决方案应该作为单独的库来开发，这样只有需要它的人才需要支付成本。
自描述Message  Self-describing Messages
 protocol buffer不包含它们自己类型的描述。因此，只给出一条原始message，而没有定义其类型的对应的.proto文件，这很难提取出任何有用的数据。
但是，注意，.proto文件的内容本身可以使用protocol buffer表示。src/google/protobuf/descriptor.proto文件定义了所涉及的message类型。 protoc可以输出一个FileDescriptorSet－表示一组.proto文件－使用--descriptor_set_out选项。这样，你可以像以下定义一个自描述的message：
syntax = &amp;quot;proto3&amp;quot;;import &amp;quot;google/protobuf/any.proto&amp;quot;;import &amp;quot;google/protobuf/descriptor.proto&amp;quot;;message SelfDescribingMessage {// Set of FileDescriptorProtos which describe the type and its dependencies.google.protobuf.FileDescriptorSet descriptor_set = 1;// The message and its type, encoded as an Any message.</description>
    </item>
    
    <item>
      <title>Protocol Buffers - 简介</title>
      <link>https://zylhorse.github.io/blog/data-structure/protocol-buffers/instroduction/</link>
      <pubDate>Thu, 28 Oct 2021 00:00:00 +0000</pubDate>
      
      <guid>https://zylhorse.github.io/blog/data-structure/protocol-buffers/instroduction/</guid>
      <description>概述 Protocol Buffers 是一种语言无关、平台无关，可扩展的序列化结构数据的机制。- 类似XML，但是更小、更快、更简单。 只需定义一次数据结构，就可以生成指定的源代码，使用不同的语言向数据流读取和写入结构数据。
Protocol Buffers目前支持生成Java、Python、Objective-C和C++等语言的代码。 在proto3版本中，新增Dart、Go、Ruby和C#等更多语言。</description>
    </item>
    
    <item>
      <title>Protocol Buffers - 编码规范</title>
      <link>https://zylhorse.github.io/blog/data-structure/protocol-buffers/style_guide/</link>
      <pubDate>Thu, 28 Oct 2021 00:00:00 +0000</pubDate>
      
      <guid>https://zylhorse.github.io/blog/data-structure/protocol-buffers/style_guide/</guid>
      <description>这篇文章讲述.proto文件的编写规范。根据以下约定，将会使你的protocol buffer messgae定义和它们对应的类保持一致并易于阅读。
注意，protocol buffer规范是随着时间改变的，因此你可能会看到用不同的约定或格式编写的.proto文件。 当你修改这些文件的时候，请尊重现有的格式。保持一致就好。但是当你创建新的.proto文件时，最好采用当前的格式。
标准文件格式  Standard file formatting
  保持每一行长度限制在80字符内 使用2个空格缩进 字符串最好使用双引号  文件结构  File structure
 文件应该命名为: lower_snake_case.proto
所有的文件应该按照以下习惯排列：
 License header File overview(文件概述) Syntax Package Imports (需要排序) File options(文件选项) Everything else (其它声明)  Packages package名称应该时小写，并且应该对应目录层级。e.g.,如果文件在my/package中，那么package名字应该是my.package。
Message和字段名  Message and field names
 message: 使用驼峰命名法(首字母大写),例如: SongServerRequest.
字段: 使用underscore_separated_names命名(包括oneof和extension),例如: song_name。 Use CamelCase (with an initial capital) for message names – for example, SongServerRequest. Use underscore_separated_names for field names (including oneof field and extension names) – for example, song_name.</description>
    </item>
    
    <item>
      <title>Protocol Buffers - 规范</title>
      <link>https://zylhorse.github.io/blog/data-structure/protocol-buffers/reference/</link>
      <pubDate>Thu, 28 Oct 2021 00:00:00 +0000</pubDate>
      
      <guid>https://zylhorse.github.io/blog/data-structure/protocol-buffers/reference/</guid>
      <description>本文是Protocol Buffers语言规范的参考文档。语法使用EBNF.
 [PB2] 表示pb version2 的规范
[PB3] 表示pb version3 的规范
 | alternation() grouping[] option (zero or one time){} repetition (any number of times)词法元素  Lexical elements
 字母和数字  Letters and digits
 letter = &amp;quot;A&amp;quot; … &amp;quot;Z&amp;quot; | &amp;quot;a&amp;quot; … &amp;quot;z&amp;quot;[PB2] capitalLetter = &amp;quot;A&amp;quot; … &amp;quot;Z&amp;quot;decimalDigit = &amp;quot;0&amp;quot; … &amp;quot;9&amp;quot;octalDigit = &amp;quot;0&amp;quot; … &amp;quot;7&amp;quot;hexDigit = &amp;quot;0&amp;quot; … &amp;quot;9&amp;quot; | &amp;quot;A&amp;quot; … &amp;quot;F&amp;quot; | &amp;quot;a&amp;quot; … &amp;quot;f&amp;quot;标识符  Identifiers</description>
    </item>
    
    <item>
      <title>数据结构-RingBuffer</title>
      <link>https://zylhorse.github.io/blog/data-structure/ringbuffer/</link>
      <pubDate>Fri, 23 Mar 2018 00:00:00 +0000</pubDate>
      
      <guid>https://zylhorse.github.io/blog/data-structure/ringbuffer/</guid>
      <description></description>
    </item>
    
    <item>
      <title>数据结构-RBTree</title>
      <link>https://zylhorse.github.io/blog/data-structure/rbtree/</link>
      <pubDate>Sat, 18 Nov 2017 00:00:00 +0000</pubDate>
      
      <guid>https://zylhorse.github.io/blog/data-structure/rbtree/</guid>
      <description></description>
    </item>
    
    <item>
      <title>数据结构-BTree</title>
      <link>https://zylhorse.github.io/blog/data-structure/btree/</link>
      <pubDate>Sat, 11 Nov 2017 00:00:00 +0000</pubDate>
      
      <guid>https://zylhorse.github.io/blog/data-structure/btree/</guid>
      <description></description>
    </item>
    
    <item>
      <title>数据结构-Huffman</title>
      <link>https://zylhorse.github.io/blog/data-structure/huffman/</link>
      <pubDate>Sun, 28 May 2017 00:00:00 +0000</pubDate>
      
      <guid>https://zylhorse.github.io/blog/data-structure/huffman/</guid>
      <description></description>
    </item>
    
    <item>
      <title>数据结构-Bitmap</title>
      <link>https://zylhorse.github.io/blog/data-structure/bitmap/</link>
      <pubDate>Fri, 03 Feb 2017 00:00:00 +0000</pubDate>
      
      <guid>https://zylhorse.github.io/blog/data-structure/bitmap/</guid>
      <description></description>
    </item>
    
  </channel>
</rss>
