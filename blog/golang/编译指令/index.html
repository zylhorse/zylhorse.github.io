<!doctype html>
<html lang="zh-cn">
  <head>
  <meta charset="utf-8">
<title>Golang-编译指令 - zylhorse blog</title>
<meta name="viewport" content="width=device-width, initial-scale=1">


  <link rel="shortcut icon" href="/img/favicon/favicon-32x32.ico?v=1">

<meta name="generator" content="Hugo 0.93.0-DEV" /><meta itemprop="name" content="Golang-编译指令">
<meta itemprop="description" content="Command compile go compile, 在命令行的调用为go tool compile。编译一个由命令行指定的多个文件组成的Go包。 执行后生成一个目标文件，文件名是第一个文件的基础名称，后缀是.o。后续该目标文件和其它 目标文件可以联合组成一个归档文件或者直接传递给连接器(go tool link). 如果使用-pack 调用，编译器直接组装成归档文件，绕过生成中间目标文件。
编译生成的文件内容包含由包导出的符号的类型信息和该包导入的其它引用包的符号的类型信息。 因此在编译包P的client时，不需要读取P依赖的文件，只需要读取P的编译输出即可。
Command Line 使用方法:
go tool compile [flags] file...
命令行指定的文件必须是go编码类型文件，且所有文件必须是同一个package的。 所有目标系统和体系结构都使用相同的编译器。环境变量GOOS和GOARCH用来设置期望的目标。
flags
-D path设置本地导入的相对路径,默认为$GOROOT-I dir1 -I dir2查询完$GOROOT/pkg/$GOOS_$GOARCH目录后再到dir1,dir2等目录下搜索导入的package-L在错误消息中显示完整的文件路径-N禁用编译优化-S将汇编程序表打印到标准输出(只包含代码)-S -S将汇编程序表打印到标准输出(包含代码和数据)-V打印编译器版本并退出-asmhdr file将汇编头写入文件-buildid id记录id作为导出元数据中的构建id-blockprofile file将编译的块分析写入文件-c int编译时并发执行。1表示不并发执行(默认1)-complete假设package中没有非go组件-cpuprofile file将编译的CPU分析写入文件-dynlink在共享库中允许引入Go符号(实验性)-e删除错误报告数量的限制(默认10)-goversion string指定runtime需要的`go tool`版本。当runtime版本和指定的版本不匹配时退出。-h当检测到第一个错误时，停止并进行堆栈trace。-importcfg file从指定文件读取import配置文件中需要指出importmap,packagefile-importmap old=new编译时将&quot;old&quot;导入解释为&quot;new&quot;导入importmap参数可以重复，用以添加多个映射。-installsuffix suffix到$GOROOT/pkg/$GOOS_$GOARCH_suffix下检索packages， 而不是 $GOROOT/pkg/$GOOS_$GOARCH."><meta itemprop="datePublished" content="2020-02-05T00:00:00+00:00" />
<meta itemprop="dateModified" content="2020-02-05T00:00:00+00:00" />
<meta itemprop="wordCount" content="281">
<meta itemprop="keywords" content="," /><meta property="og:title" content="Golang-编译指令" />
<meta property="og:description" content="Command compile go compile, 在命令行的调用为go tool compile。编译一个由命令行指定的多个文件组成的Go包。 执行后生成一个目标文件，文件名是第一个文件的基础名称，后缀是.o。后续该目标文件和其它 目标文件可以联合组成一个归档文件或者直接传递给连接器(go tool link). 如果使用-pack 调用，编译器直接组装成归档文件，绕过生成中间目标文件。
编译生成的文件内容包含由包导出的符号的类型信息和该包导入的其它引用包的符号的类型信息。 因此在编译包P的client时，不需要读取P依赖的文件，只需要读取P的编译输出即可。
Command Line 使用方法:
go tool compile [flags] file...
命令行指定的文件必须是go编码类型文件，且所有文件必须是同一个package的。 所有目标系统和体系结构都使用相同的编译器。环境变量GOOS和GOARCH用来设置期望的目标。
flags
-D path设置本地导入的相对路径,默认为$GOROOT-I dir1 -I dir2查询完$GOROOT/pkg/$GOOS_$GOARCH目录后再到dir1,dir2等目录下搜索导入的package-L在错误消息中显示完整的文件路径-N禁用编译优化-S将汇编程序表打印到标准输出(只包含代码)-S -S将汇编程序表打印到标准输出(包含代码和数据)-V打印编译器版本并退出-asmhdr file将汇编头写入文件-buildid id记录id作为导出元数据中的构建id-blockprofile file将编译的块分析写入文件-c int编译时并发执行。1表示不并发执行(默认1)-complete假设package中没有非go组件-cpuprofile file将编译的CPU分析写入文件-dynlink在共享库中允许引入Go符号(实验性)-e删除错误报告数量的限制(默认10)-goversion string指定runtime需要的`go tool`版本。当runtime版本和指定的版本不匹配时退出。-h当检测到第一个错误时，停止并进行堆栈trace。-importcfg file从指定文件读取import配置文件中需要指出importmap,packagefile-importmap old=new编译时将&quot;old&quot;导入解释为&quot;new&quot;导入importmap参数可以重复，用以添加多个映射。-installsuffix suffix到$GOROOT/pkg/$GOOS_$GOARCH_suffix下检索packages， 而不是 $GOROOT/pkg/$GOOS_$GOARCH." />
<meta property="og:type" content="article" />
<meta property="og:url" content="https://zylhorse.github.io/blog/golang/%E7%BC%96%E8%AF%91%E6%8C%87%E4%BB%A4/" /><meta property="article:section" content="blog" />
<meta property="article:published_time" content="2020-02-05T00:00:00+00:00" />
<meta property="article:modified_time" content="2020-02-05T00:00:00+00:00" />

<meta name="twitter:card" content="summary"/>
<meta name="twitter:title" content="Golang-编译指令"/>
<meta name="twitter:description" content="Command compile go compile, 在命令行的调用为go tool compile。编译一个由命令行指定的多个文件组成的Go包。 执行后生成一个目标文件，文件名是第一个文件的基础名称，后缀是.o。后续该目标文件和其它 目标文件可以联合组成一个归档文件或者直接传递给连接器(go tool link). 如果使用-pack 调用，编译器直接组装成归档文件，绕过生成中间目标文件。
编译生成的文件内容包含由包导出的符号的类型信息和该包导入的其它引用包的符号的类型信息。 因此在编译包P的client时，不需要读取P依赖的文件，只需要读取P的编译输出即可。
Command Line 使用方法:
go tool compile [flags] file...
命令行指定的文件必须是go编码类型文件，且所有文件必须是同一个package的。 所有目标系统和体系结构都使用相同的编译器。环境变量GOOS和GOARCH用来设置期望的目标。
flags
-D path设置本地导入的相对路径,默认为$GOROOT-I dir1 -I dir2查询完$GOROOT/pkg/$GOOS_$GOARCH目录后再到dir1,dir2等目录下搜索导入的package-L在错误消息中显示完整的文件路径-N禁用编译优化-S将汇编程序表打印到标准输出(只包含代码)-S -S将汇编程序表打印到标准输出(包含代码和数据)-V打印编译器版本并退出-asmhdr file将汇编头写入文件-buildid id记录id作为导出元数据中的构建id-blockprofile file将编译的块分析写入文件-c int编译时并发执行。1表示不并发执行(默认1)-complete假设package中没有非go组件-cpuprofile file将编译的CPU分析写入文件-dynlink在共享库中允许引入Go符号(实验性)-e删除错误报告数量的限制(默认10)-goversion string指定runtime需要的`go tool`版本。当runtime版本和指定的版本不匹配时退出。-h当检测到第一个错误时，停止并进行堆栈trace。-importcfg file从指定文件读取import配置文件中需要指出importmap,packagefile-importmap old=new编译时将&quot;old&quot;导入解释为&quot;new&quot;导入importmap参数可以重复，用以添加多个映射。-installsuffix suffix到$GOROOT/pkg/$GOOS_$GOARCH_suffix下检索packages， 而不是 $GOROOT/pkg/$GOOS_$GOARCH."/>
<link rel="stylesheet" href="/css/bundle.min.e6b64d256349a1e498e56d1c2593ba6a2f46192823f7f0403a175b4bb8f2ee84.css" integrity="sha256-5rZNJWNJoeSY5W0cJZO6ai9GGSgj9/BAOhdbS7jy7oQ="><link rel="stylesheet" href="/css/add-on.css">
</head>

  <body>
    

<header id="site-header">
  <nav id="site-nav">
    <h1 class="nav-title">
      <a href="/" class="nav">
        
          博客
        
      </a>
    </h1>
    <menu id="site-nav-menu" class="flyout-menu menu">
      
        
          
          <a href="/" class="nav link"><i class='fas fa-home'></i> 主页</a>
        
      
        
          
          <a href="/blog/" class="nav link"><i class='far fa-newspaper'></i> 博客</a>
        
      
        
          
          <a href="/categories/" class="nav link"><i class='fas fa-sitemap'></i> 分类</a>
        
      
        
          
          <a href="/tags/" class="nav link"><i class='fas fas fa-tags'></i> 标签</a>
        
      
        
          
          <a href="/about/" class="nav link"><i class='far fa-id-card'></i> 关于</a>
        
      
      
      <a href="#search-input" class="nav link search-toggle"><i class="fas fa-search">&nbsp;</i>Search</a>
    </menu>
    <a href="#search-input" class="nav search-toggle"><i class="fas fa-search fa-2x">&nbsp;</i></a>
    
    
    <a href="#site-nav" class="nav nav-toggle"><i class="fas fa-bars fa-2x"></i></a>
  </nav>
  <menu id="search" class="menu"><input id="search-input" class="search-input menu"></input><div id="search-results" class="search-results menu"></div></menu>
  
  
</header>

    <main id="site-main">
      
  <article class="post">
    <header>
  <div class="title">
    
      <h2><a href="/blog/golang/%E7%BC%96%E8%AF%91%E6%8C%87%E4%BB%A4/">Golang-编译指令</a></h2>
    
    
  </div>
</header>
    <div class="meta">
    <p title="Created" class="fas fa-calendar-plus">
        <time datetime="2020-02-05 00:00:00 &#43;0000 UTC">2020-02-05</time>
    </p>
    
        <p title="Author" class="fas fa-user">zylhorse
        </p>
    
    
        <p title="ReadingTime" class="fas fa-stopwatch">
            5分钟
        </p>
    
    
        <p id="busuanzi_container_page_pv">
        <p id="busuanzi_value_page_pv" title="Vistors" class="fas fa-eye">
        </p>
        </p>
    
</div>
    <div class="content">
      
      <h2 id="command-compile">Command compile</h2>
<p>go compile, 在命令行的调用为<code>go tool compile</code>。编译一个由命令行指定的多个文件组成的Go包。
执行后生成一个目标文件，文件名是第一个文件的基础名称，后缀是<code>.o</code>。后续该目标文件和其它
目标文件可以联合组成一个归档文件或者直接传递给连接器(<code>go tool link</code>). 如果使用<code>-pack</code>
调用，编译器直接组装成归档文件，绕过生成中间目标文件。<br>
编译生成的文件内容包含由包导出的符号的类型信息和该包导入的其它引用包的符号的类型信息。
因此在编译包P的<code>client</code>时，不需要读取P依赖的文件，只需要读取P的编译输出即可。</p>
<h2 id="command-line">Command Line</h2>
<p><em><strong>使用方法:</strong></em><br>
<code>go tool compile [flags] file...</code></p>
<p>命令行指定的文件必须是<code>go</code>编码类型文件，且所有文件必须是同一个<code>package</code>的。
所有目标系统和体系结构都使用相同的编译器。环境变量<code>GOOS</code>和<code>GOARCH</code>用来设置期望的目标。</p>
<p><em><strong>flags</strong></em></p>
<pre tabindex="0"><code>-D path
    设置本地导入的相对路径,默认为$GOROOT
-I dir1 -I dir2
    查询完$GOROOT/pkg/$GOOS_$GOARCH目录后
    再到dir1,dir2等目录下搜索导入的package
-L
    在错误消息中显示完整的文件路径
-N
    禁用编译优化
-S
    将汇编程序表打印到标准输出(只包含代码)
-S -S
    将汇编程序表打印到标准输出(包含代码和数据)
-V
    打印编译器版本并退出
-asmhdr file
    将汇编头写入文件
-buildid id
    记录id作为导出元数据中的构建id
-blockprofile file
    将编译的块分析写入文件
-c int
    编译时并发执行。1表示不并发执行(默认1)
-complete
    假设package中没有非go组件
-cpuprofile file
    将编译的CPU分析写入文件
-dynlink
    在共享库中允许引入Go符号(实验性)
-e
    删除错误报告数量的限制(默认10)
-goversion string
    指定runtime需要的`go tool`版本。
    当runtime版本和指定的版本不匹配时退出。
-h
    当检测到第一个错误时，停止并进行堆栈trace。
-importcfg file
    从指定文件读取import配置
    文件中需要指出importmap,packagefile
-importmap old=new
    编译时将&quot;old&quot;导入解释为&quot;new&quot;导入
    importmap参数可以重复，用以添加多个映射。
-installsuffix suffix
    到$GOROOT/pkg/$GOOS_$GOARCH_suffix下检索packages， 而不是 $GOROOT/pkg/$GOOS_$GOARCH.
-l
    禁止代码嵌入
-lang version
    设置编译器语言版本，例如: -lang=go1.12.默认为当前版本
-linkobj file
    将特定于连接器的对象写入文件，特定于编译器的对象写入通常的输出文件(此文件可以由-o指定)。
    不指定该标记，-o指定的输出是连接器和编译器两者输入的组合。
-m
    打印优化决策
-memprofile file
    指定编译时内存分析写入的文件
-memprofilerate rate
    设置编译时runtime.MemProfileRate的值
-msan
    插入c/c++ [Memory Sanitizer]的调用
-mutexprofile file
    指定编译时mutex分析写入的文件
-nolocalimports
    禁止本地(相对)导入
-o file
    指定对象写入的文件(默认为xx.o，或者有-pack标记时为file.a)
-p path
    为要编译的代码指定预期的包导入路径，并诊断可能会导致循环依赖的导入。
-pack
    输出一个包(归档)文件而不是目标文件。
-race
    开启竞争检测
-s
    告警可以简化的符合字面值。
-shared
    生成可以连接到共享库中的代码
-spectre list
    开启spectre缓解方法(all,index,ret)
-traceprofile file
    指定执行trace写入的文件。
-trimpath prefix
    指定从记录资源文件中删除的前缀。
</code></pre><p><em><strong>调试信息相关的flags</strong></em></p>
<pre tabindex="0"><code>-dwarf
    生成dwarf符号
-dwarflocationlists
    添加本地列表到[DWARF]
-gendwarfinl int
    生成DWARF内联信息记录(default 2)
</code></pre><p><em><strong>编译器自身调试相关flags</strong></em></p>
<pre tabindex="0"><code>-E
    导出符号
-K
    丢弃行号
-d list
    打印list中每项调试信息。 使用-d help 查看更多信息。
-live
    活性分析
-v
    增加调试级别
-%
    调试非静态初始化器
-W
    在类型检查后调试解析树
-f
    调试栈帧
-i
    调试行号堆栈
-j
    调试运行时初始化的变量。
-r
    调试生成的包装器
-w
    调试类型检查
</code></pre><h2 id="编译器指令">编译器指令</h2>
<p>golang编译器接受注释形式的指令。为了和非指令的注释区分，指令行的注释符和指令之间不需要空格。
然而，由于指令也是注释，不能识别指令约定或特定指令的工具可以像其它任何注释一样跳过一条指令。</p>
<p><em><strong>行指令有以下几种格式:</strong></em></p>
<pre tabindex="0"><code>//line :line
//line :line:col
//line filename:line
//line filename:line:col

/*line :line*/
/*line :line:col*/
/*line filename:line*/
/*line filename:line:col*/
</code></pre><p>为了被识别为行指令，注释必须以<code>//line</code>或者<code>/*line</code>开头，后跟空格，且最少包含一个<code>:</code>。
行指令指定后面字符的源位置，来自指定的文件、行、列：对于<code>//line</code>这种格式，字符是下一行，
对于<code>/*line</code>这种格式，字符紧接结束符<code>*/</code>。如果没有指定文件名和列号，那么记录文件名为空。
否则文件名为最近记录的文件名(其实文件名为前一条行指令指定的文件名)。如果行指令没有指定列号，
那么在下一条指令前列都是未知的，并且编译器不会报告该区间的列号。行指令文本从后往前解释：
如果尾部的:ddd中ddd&gt;0则将:ddd从指令文本中剥离，第二个:ddd进行相同的处理.
在此之前的任何内容都被认为是文件名。无效的行号和列号都被报告为错误。</p>
<p>示例:</p>
<pre tabindex="0"><code>//line foo.go:10    文件名是foo.go，行号是10
//line C:foo.go:10  文件名允许有冒号,这里文件名是C:foo.go，行号是10
//line  a:100 :10   文件名允许有空格，这里文件名是&quot; a:100 &quot;(不含双引号)
/*line :10:20*/x    x的位置是当前文件的第10行20列
/*line foo: 10 */   这条注释被认为是无效的行指令(行号周围有额外的空格)  
</code></pre><p>行指令一般出现在机器生成的代码中，以便编译器和调试器将原始输入的位置报告给生成器。</p>
<p>行指令是一个特殊的历史情况:所有其它的指令都是<code>//go:name</code>格式，表明它们都是由Go工具链定义。
每条指令必须单独放置一行，注释前只允许前置空格或者制表符。每条指令都将应用于紧跟它的代码，
这些代码通常都是一个声明。</p>
<p><code>//go:noescape</code>
指令<code>//go:noescepe</code>必须紧跟一个没有函数体的函数声明(意味着该函数的实现不是用Go写的)。
它指定该函数不允许任何作为参数传递的指针逃逸到堆中或函数返回的值中。这个信息在编译器
对调用函数的Go代码做逃逸分析时使用。</p>
<p><code>//go:unitptrescapes</code>
指令<code>//go:uintptrescapes</code>必须紧跟一个函数声明。它指定该函数的uintptr类型的参数
可能是已经被转换为uintptr的指针值，并且必须被gc如此处理。从指针到uintptr的转换
必须出现在任何调用该函数的参数列表中。这个指令对于一些底层系统调用实现是必要的，
其它情况应该避免使用。</p>
<p><code>//go:noinline</code>
指令<code>//go:noinline</code>后面必须跟一个函数声明。它指定对这个函数的调用不能内联，
覆盖编译器通常的优化规则。这个指令通常只有在特殊的运行时函数或者调试编译器时需要。</p>
<p><code>//go:norace</code>
指令<code>//go:norace</code>后面必须跟一个函数声明。它指定函数的内存访问必须被被竞争检测器忽略。
当竞争检测器运行时不安全时， 底层代码经常用。</p>
<p><code>go:nosplit</code>
指令<code>//go:nosplit</code>后面必须跟一个函数声明。它指定函数必须忽略堆栈溢出检查。
当调用goroutine抢占不合法时，底层运行时代码经常用。</p>
<p><code>go:linkname localname [importpath.name]</code>
这个特殊的指令并不适用于后面跟着的Go代码。相反，<code>//go:linkname</code>指令指示编译器使用
<code>importpath.name</code>作为代码中声明为<code>localname</code>的变量或函数的对象文件符号名。如果
<code>importpath.name</code>参数被忽略，该指令使用默认的对象文件符号名，并且只起到让其它package
可以访问该符号的作用。因为该指令可以颠覆类型系统和package的模块化，
所以它只在导入了<code>unsafe</code>包的文件中启用。</p>
<p><code>go:generate</code>
格式: <code>// go:gererate command args...</code><br>
使用： <code>go generate</code>命令会自动执行<code>go:generate</code> 中注释的命令。</p>
<h2 id="问题">问题</h2>
<p><code>can't find imports package</code>
这是编译器找不到<code>package</code>目录， 解决方案：</p>
<ol>
<li>到导入的<code>package</code>目录下执行<code>go install *.go</code></li>
<li>在当前<code>package</code>目录下执行<code>go tool compile -S -I $GOROOT/pkg/$GOOS_$GOARCH *.go</code></li>
</ol>

      
    <h2>参考</h2>
    <ul>
        
            
                <li><a target="_blank" href="https://golang.org/cmd/compile/">Command Compile</a></li>
            
        
    </ul>

    </div>
    <footer>
      <div class="stats">
  
    <ul class="categories">
      
        
          <li><a class="article-terms-link" href="/categories/golang/">Golang</a></li>
        
      
    </ul>
  
  
    <ul class="tags">
      
        
          <li><a class="article-terms-link" href="/tags/"></a></li>
        
      
    </ul>
  
</div>

    </footer>
  </article>
  
    <aside id="toc">
      <div class="toc-title">目录</div>
      <nav id="TableOfContents">
  <ul>
    <li><a href="#command-compile">Command compile</a></li>
    <li><a href="#command-line">Command Line</a></li>
    <li><a href="#编译器指令">编译器指令</a></li>
    <li><a href="#问题">问题</a></li>
  </ul>
</nav>
    </aside>
  
  <div class="pagination">
    
      <a href="/blog/golang/%E6%95%B0%E6%8D%AE%E5%BA%93/" class="button left"><span>Golang数据库-数据类型转换</span></a>
    
    
      <a href="/blog/golang/%E4%BA%A4%E5%8F%89%E7%BC%96%E8%AF%91/" class="button right"><span>Golang跨平台之交叉编译</span></a>
    
  </div>
  
    <hr/>
    
  <article class="ucomments">
    <script src="https://utteranc.es/client.js"
            repo=zylhorse/zylhorse.github.io
            issue-term=title
            label=Golang
            theme=github-light
            crossorigin="anonymous"
            async>
    </script>
  </article>



  

      <script src="/js/highlight.js"></script>
    
    <script>hljs.initHighlightingOnLoad();</script><script src="/js/bundle.min.ad234a7d27a481f0d6214513d28dbfbe759d77531bda10b3d393b978c983724c.js" integrity="sha256-rSNKfSekgfDWIUUT0o2/vnWdd1Mb2hCz05O5eMmDckw="></script>
    <script src="/js/add-on.js"></script>
  <script async src="//busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js"></script>
    </main>









  </body>
</html>
