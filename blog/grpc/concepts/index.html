<!doctype html>
<html lang="zh-cn">
  <head>
  <meta charset="utf-8">
<title>gRPC核心概念，架构，生命周期 - zylhorse blog</title>
<meta name="viewport" content="width=device-width, initial-scale=1">


  <link rel="shortcut icon" href="/img/favicon/favicon-32x32.ico?v=1">

<meta name="generator" content="Hugo 0.93.0-DEV" /><meta itemprop="name" content="gRPC核心概念，架构，生命周期">
<meta itemprop="description" content="本文介绍gRPC的主要概念，架构和生命周期
服务定义 与其它RPC系统类似，gRPC基于服务定义的概念，指定可以远程调用(使用自定义参数和返回值)的方法。 默认情况下，gRPC使用protocol buffers作为IDL，用以描述服务接口和负载信息的结构。当然，如果需要，你可以使用其它方式替代。
service HelloService {rpc SayHello (HelloRequest) returns (HelloResponse);}message HelloRequest {string greeting = 1;}message HelloResponse {string reply = 1;}gRPC提供四种定义服务的方法:
 Unary RPC, client发送单个请求到server并返回单个响应： rpc SayHello(HelloRequest) returns (HelloResponse); Server Stream RPC，client发送单个请求,server返回一个流，用以读取返回的一系列信息。 client从流中读取数据直到没有更多的信息。gRPC保证单个RPC调用中的信息顺序。 rpc LotsOfReplies(HelloRequest) returns (stream HelloResponse); Client Stream RPC, client写入一系列的信息并使用流发送它们到服务器。一旦client结束写信息， 就会等待server读取并返回响应。gRPC保证打个RPC调用中的信息顺序。 rpc LotsOfGreetings(stream HelloRequest) returns (HelloResponse); Bidirectional Stream RPC, client和server都会使用一个读写流发送一系列的信息。这两个流是独立运行的， 因此client和server可以任意的读写数据。例如:sever会在接收完所有的client信息后返回响应信息, 或者交替的接收一个client信息后返回一个响应信息，或者其它方式。 每个流中信息的顺序被保留。 rpc BidiHello(stream HelloRequest) returns (stream HelloResponse);  API使用 gRPC提供的protocol buffer插件,使用."><meta itemprop="datePublished" content="2020-12-23T00:00:00+00:00" />
<meta itemprop="dateModified" content="2020-12-23T00:00:00+00:00" />
<meta itemprop="wordCount" content="146">
<meta itemprop="keywords" content="" /><meta property="og:title" content="gRPC核心概念，架构，生命周期" />
<meta property="og:description" content="本文介绍gRPC的主要概念，架构和生命周期
服务定义 与其它RPC系统类似，gRPC基于服务定义的概念，指定可以远程调用(使用自定义参数和返回值)的方法。 默认情况下，gRPC使用protocol buffers作为IDL，用以描述服务接口和负载信息的结构。当然，如果需要，你可以使用其它方式替代。
service HelloService {rpc SayHello (HelloRequest) returns (HelloResponse);}message HelloRequest {string greeting = 1;}message HelloResponse {string reply = 1;}gRPC提供四种定义服务的方法:
 Unary RPC, client发送单个请求到server并返回单个响应： rpc SayHello(HelloRequest) returns (HelloResponse); Server Stream RPC，client发送单个请求,server返回一个流，用以读取返回的一系列信息。 client从流中读取数据直到没有更多的信息。gRPC保证单个RPC调用中的信息顺序。 rpc LotsOfReplies(HelloRequest) returns (stream HelloResponse); Client Stream RPC, client写入一系列的信息并使用流发送它们到服务器。一旦client结束写信息， 就会等待server读取并返回响应。gRPC保证打个RPC调用中的信息顺序。 rpc LotsOfGreetings(stream HelloRequest) returns (HelloResponse); Bidirectional Stream RPC, client和server都会使用一个读写流发送一系列的信息。这两个流是独立运行的， 因此client和server可以任意的读写数据。例如:sever会在接收完所有的client信息后返回响应信息, 或者交替的接收一个client信息后返回一个响应信息，或者其它方式。 每个流中信息的顺序被保留。 rpc BidiHello(stream HelloRequest) returns (stream HelloResponse);  API使用 gRPC提供的protocol buffer插件,使用." />
<meta property="og:type" content="article" />
<meta property="og:url" content="https://zylhorse.github.io/blog/grpc/concepts/" /><meta property="article:section" content="blog" />
<meta property="article:published_time" content="2020-12-23T00:00:00+00:00" />
<meta property="article:modified_time" content="2020-12-23T00:00:00+00:00" />

<meta name="twitter:card" content="summary"/>
<meta name="twitter:title" content="gRPC核心概念，架构，生命周期"/>
<meta name="twitter:description" content="本文介绍gRPC的主要概念，架构和生命周期
服务定义 与其它RPC系统类似，gRPC基于服务定义的概念，指定可以远程调用(使用自定义参数和返回值)的方法。 默认情况下，gRPC使用protocol buffers作为IDL，用以描述服务接口和负载信息的结构。当然，如果需要，你可以使用其它方式替代。
service HelloService {rpc SayHello (HelloRequest) returns (HelloResponse);}message HelloRequest {string greeting = 1;}message HelloResponse {string reply = 1;}gRPC提供四种定义服务的方法:
 Unary RPC, client发送单个请求到server并返回单个响应： rpc SayHello(HelloRequest) returns (HelloResponse); Server Stream RPC，client发送单个请求,server返回一个流，用以读取返回的一系列信息。 client从流中读取数据直到没有更多的信息。gRPC保证单个RPC调用中的信息顺序。 rpc LotsOfReplies(HelloRequest) returns (stream HelloResponse); Client Stream RPC, client写入一系列的信息并使用流发送它们到服务器。一旦client结束写信息， 就会等待server读取并返回响应。gRPC保证打个RPC调用中的信息顺序。 rpc LotsOfGreetings(stream HelloRequest) returns (HelloResponse); Bidirectional Stream RPC, client和server都会使用一个读写流发送一系列的信息。这两个流是独立运行的， 因此client和server可以任意的读写数据。例如:sever会在接收完所有的client信息后返回响应信息, 或者交替的接收一个client信息后返回一个响应信息，或者其它方式。 每个流中信息的顺序被保留。 rpc BidiHello(stream HelloRequest) returns (stream HelloResponse);  API使用 gRPC提供的protocol buffer插件,使用."/>
<link rel="stylesheet" href="/css/bundle.min.e6b64d256349a1e498e56d1c2593ba6a2f46192823f7f0403a175b4bb8f2ee84.css" integrity="sha256-5rZNJWNJoeSY5W0cJZO6ai9GGSgj9/BAOhdbS7jy7oQ="><link rel="stylesheet" href="/css/add-on.css">
</head>

  <body>
    

<header id="site-header">
  <nav id="site-nav">
    <h1 class="nav-title">
      <a href="/" class="nav">
        
          博客
        
      </a>
    </h1>
    <menu id="site-nav-menu" class="flyout-menu menu">
      
        
          
          <a href="/" class="nav link"><i class='fas fa-home'></i> 主页</a>
        
      
        
          
          <a href="/blog/" class="nav link"><i class='far fa-newspaper'></i> 博客</a>
        
      
        
          
          <a href="/categories/" class="nav link"><i class='fas fa-sitemap'></i> 分类</a>
        
      
        
          
          <a href="/tags/" class="nav link"><i class='fas fas fa-tags'></i> 标签</a>
        
      
        
          
          <a href="/about/" class="nav link"><i class='far fa-id-card'></i> 关于</a>
        
      
      
      <a href="#search-input" class="nav link search-toggle"><i class="fas fa-search">&nbsp;</i>Search</a>
    </menu>
    <a href="#search-input" class="nav search-toggle"><i class="fas fa-search fa-2x">&nbsp;</i></a>
    
    
    <a href="#site-nav" class="nav nav-toggle"><i class="fas fa-bars fa-2x"></i></a>
  </nav>
  <menu id="search" class="menu"><input id="search-input" class="search-input menu"></input><div id="search-results" class="search-results menu"></div></menu>
  
  
</header>

    <main id="site-main">
      
  <article class="post">
    <header>
  <div class="title">
    
      <h2><a href="/blog/grpc/concepts/">gRPC核心概念，架构，生命周期</a></h2>
    
    
  </div>
</header>
    <div class="meta">
    <p title="Created" class="fas fa-calendar-plus">
        <time datetime="2020-12-23 00:00:00 &#43;0000 UTC">2020-12-23</time>
    </p>
    
        <p title="Author" class="fas fa-user">zylhorse
        </p>
    
    
        <p title="ReadingTime" class="fas fa-stopwatch">
            &lt;no value&gt;分钟
        </p>
    
    
        <p id="busuanzi_container_page_pv">
        <p id="busuanzi_value_page_pv" title="Vistors" class="fas fa-eye">
        </p>
        </p>
    
</div>
    <div class="content">
      
      <p>本文介绍gRPC的主要概念，架构和生命周期</p>
<h2 id="服务定义">服务定义</h2>
<p>与其它RPC系统类似，gRPC基于服务定义的概念，指定可以远程调用(使用自定义参数和返回值)的方法。
默认情况下，gRPC使用<code>protocol buffers</code>作为IDL，用以描述服务接口和负载信息的结构。当然，如果需要，你可以使用其它方式替代。</p>
<pre tabindex="0"><code>service HelloService {
  rpc SayHello (HelloRequest) returns (HelloResponse);
}

message HelloRequest {
  string greeting = 1;
}

message HelloResponse {
  string reply = 1;
}
</code></pre><p>gRPC提供四种定义服务的方法:</p>
<ul>
<li><code>Unary RPC</code>, <code>client</code>发送单个请求到<code>server</code>并返回单个响应：
<pre tabindex="0"><code>rpc SayHello(HelloRequest) returns (HelloResponse);
</code></pre></li>
<li><code>Server Stream RPC</code>，<code>client</code>发送单个请求,<code>server</code>返回一个流，用以读取返回的一系列信息。
<code>client</code>从流中读取数据直到没有更多的信息。gRPC保证单个RPC调用中的信息顺序。
<pre tabindex="0"><code>rpc LotsOfReplies(HelloRequest) returns (stream HelloResponse);
</code></pre></li>
<li><code>Client Stream RPC</code>, <code>client</code>写入一系列的信息并使用流发送它们到服务器。一旦<code>client</code>结束写信息，
就会等待<code>server</code>读取并返回响应。gRPC保证打个RPC调用中的信息顺序。
<pre tabindex="0"><code>rpc LotsOfGreetings(stream HelloRequest) returns (HelloResponse);
</code></pre></li>
<li><code>Bidirectional Stream RPC</code>, <code>client</code>和<code>server</code>都会使用一个读写流发送一系列的信息。这两个流是独立运行的，
因此<code>client</code>和<code>server</code>可以任意的读写数据。例如:<code>sever</code>会在接收完所有的<code>client</code>信息后返回响应信息,
或者交替的接收一个<code>client</code>信息后返回一个响应信息，或者其它方式。 每个流中信息的顺序被保留。
<pre tabindex="0"><code>rpc BidiHello(stream HelloRequest) returns (stream HelloResponse);
</code></pre></li>
</ul>
<h2 id="api使用">API使用</h2>
<p>gRPC提供的<code>protocol buffer</code>插件,使用<code>.proto</code>文件中定义的<code>service</code>生成<code>client</code>-<code>server</code>代码。
用户通常在<code>client</code>端调用这些API，并在<code>server</code>端实现对应的API。</p>
<ul>
<li>在<code>server</code>端,<code>server</code>实现<code>service</code>中声明的方法，并运行gRPC <code>server</code>处理<code>client</code>调用。
gRPC基础设施解码传入的请求，调用<code>service</code>方法并且编码<code>service</code>响应。</li>
<li>在<code>client</code>端,<code>client</code>有一个本地对象<code>stub</code>，它实现了与<code>service</code>相同的方法。
<code>client</code>可以在本地调用这些方法, 包装请求参数为对应的<code>protocol buffer</code>信息类型，
gRPC发送请求到<code>server</code>并返回<code>protocol buffer</code>类型的响应信息。</li>
</ul>
<h2 id="同步vs异步">同步vs异步</h2>
<p>阻塞同步RPC直到接收服务器返回响应，是最接近RPC期望实现的过程调用的抽象。另一方面，网络本质是异步的，
并且在许多场景中，希望RPC能够不阻塞当前线程。<br>
大多数语言实现的gRPC API都有同步和异步两种模式。这些可以到相应语言的教程和参考文档中查看。</p>
<h2 id="rpc生命周期">RPC生命周期</h2>
<p>本节中，可以更近一步的了解gRPC <code>client</code>调用 <code>server</code>方法的细节。</p>
<h3 id="unary-rpc">Unary-RPC</h3>
<p>首先我们考虑最简单的RPC调用类型，<code>client</code>发送单个请求并且获取单个响应。</p>
<ol>
<li>一旦<code>client</code>调用<code>stub</code>中的方法，<code>server</code>就会被通知<code>client</code>正在使用<a href="/blog/grpc/concepts#%E5%85%83%E7%B4%A0%E6%8D%AE">元数据</a>，方法名，
<a href="/blog/grpc/concepts#%E8%B6%85%E6%97%B6%E6%97%B6%E9%97%B4">超时时间</a>进行RPC。</li>
<li>然后<code>server</code>可以马上返回自己的初始元数据(必须在任何响应之前发送)，或者等待<code>clien</code>请求信息。哪个先发生，应该根据具体的应用。</li>
<li>一旦<code>server</code>接收到<code>client</code>的请求信息，它将执行必要的工作并创建响应信息。响应信息(成功时返回)，状态详情(状态码和状态信息)，
可选的元数据会一并返回给<code>client</code>。</li>
<li>如果响应状态是正确的，<code>client</code>会获取到响应，<code>client</code>端完成处理过程。</li>
</ol>
<h3 id="server-streaming-rpc">Server-Streaming-RPC</h3>
<p><code>server-streaming RPC</code> 和<code>unary RPC</code>类似，希望<code>client</code>请求时返回流信息。等到所有的信息都返回完成，
<code>server</code>再将状态详情(状态码和状态信息)，可选的元数据会一并返回给<code>client</code>，<code>server</code>端完成处理过程。
<code>client</code>在接收到所有的<code>server</code>端信息后，<code>client</code>端完成处理过程。</p>
<h3 id="client-streaming-rpc">Client-Streaming-RPC</h3>
<p><code>client-streaming RPC</code>和<code>unary RPC</code>类似，希望<code>client</code>请求时发送流信息到<code>server</code>。
<code>server</code>返回单个信息(包含状态详情和可选的元素据)，不一定等到<code>server</code>接收完所有的<code>client</code>信息。</p>
<h3 id="bidirectional-streaming-rpc">Bidirectional-Streaming-RPC</h3>
<p><code>bidirectional-streaming RPC</code>,调用的发起是由<code>client</code>调用方法和<code>server</code>接收<code>client</code>元数据、方法名、超时时间。
<code>server</code>可以选择返回它的初始元数据或等待<code>client</code>发送流信息。<br>
<code>client</code>端和<code>server</code>端流处理应该根据具体的应用。由于这两个流是独立的，<code>client</code>和<code>server</code>可以以任意顺序读写信息。
例如： <code>server</code>可以等接收完所有的<code>client</code>消息后再写自己的信息或者<code>client</code>和<code>server</code>互发<code>ping-pong</code>
(<code>server</code>获取请求后返回响应，然后客户端根据该响应信息发送另一个请求)。</p>
<h3 id="deadlinestimeouts">Deadlines/Timeouts</h3>
<p>gRPC允许<code>client</code>指定在RPC中断(返回错误DEADLINE_EXCEEDED)前等待RPC完成的时间。 在<code>server</code>端，服务可以查看某个RPC是否超时，
或者该RPC操作完成还需要多久。　　</p>
<p>指定<code>deadline</code>或<code>timeout</code>是语言相关的: 一些语言使用<code>timeout</code>(时间段),一些语言使用<code>deadline</code>(时间点)</p>
<h3 id="rpc中断">RPC中断</h3>
<p><code>client</code>和<code>server</code>独立维护和决策gRPC的调用结果，因此它们的结果可能不一致。这表示，例如：</p>
<ol>
<li>在<code>server</code>端获取RPC成功的结果(已经发送所有的响应)，但是再<code>client</code>端获取到失败的结果(响应在<code>deadline</code>后到达)。</li>
<li><code>server</code>端有同样的问题，<code>server</code>在接收完<code>client</code>端所有的请求前中断。</li>
</ol>
<h3 id="取消rpc">取消RPC</h3>
<p><code>client</code>和<code>server</code>可以在任何时间点取消一个RPC。取消操作会立刻中断RPC，并停止后续工作。</p>
<blockquote>
<p>取消操作之前所作的修改不会进行回滚</p>
</blockquote>
<h3 id="metadata">Metadata</h3>
<p><code>metadata</code>是关于一个RPC调用的信息说明(例如: 权限明细),以<code>key-value</code>列表的表单形式表示，
<code>key</code>是<code>string</code>类型， <code>value</code>是<code>string</code>或<code>binary data</code>类型。<br>
<code>metadata</code>对于gRPC本身也是不透明的-它让<code>client</code>提供调用<code>server</code>相关的信息，反之亦然。</p>
<h3 id="channels">Channels</h3>
<p>gRPC的<code>channel</code>提供了在特定主机和端口与<code>server</code>的连接。创建<code>client stub</code>时使用<code>channel</code>,
<code>client</code>可以指定<code>channel</code>的参数来修改gRPC的默认行为，例如:是否开启和关闭信息压缩。<code>channel</code>有状态属性，包括<code>conencted</code>和<code>idle</code>。<br>
gRPC如何处理<code>channel</code>的关闭事件是语言相关的。 有些语言甚至允许查询<code>channel</code>的状态。</p>

      
    <h2>参考</h2>
    <ul>
        
            
                <li><a target="_blank" href="https://grpc.io/docs/what-is-grpc/core-concepts/">Core concepts, architecture and lifecycle</a></li>
            
        
    </ul>

    </div>
    <footer>
      <div class="stats">
  
    <ul class="categories">
      
        
          <li><a class="article-terms-link" href="/categories/grpc/">gRPC</a></li>
        
      
    </ul>
  
  
    <ul class="tags">
      <li>None</li>
    </ul>
  
</div>

    </footer>
  </article>
  
    <aside id="toc">
      <div class="toc-title">目录</div>
      <nav id="TableOfContents">
  <ul>
    <li><a href="#服务定义">服务定义</a></li>
    <li><a href="#api使用">API使用</a></li>
    <li><a href="#同步vs异步">同步vs异步</a></li>
    <li><a href="#rpc生命周期">RPC生命周期</a>
      <ul>
        <li><a href="#unary-rpc">Unary-RPC</a></li>
        <li><a href="#server-streaming-rpc">Server-Streaming-RPC</a></li>
        <li><a href="#client-streaming-rpc">Client-Streaming-RPC</a></li>
        <li><a href="#bidirectional-streaming-rpc">Bidirectional-Streaming-RPC</a></li>
        <li><a href="#deadlinestimeouts">Deadlines/Timeouts</a></li>
        <li><a href="#rpc中断">RPC中断</a></li>
        <li><a href="#取消rpc">取消RPC</a></li>
        <li><a href="#metadata">Metadata</a></li>
        <li><a href="#channels">Channels</a></li>
      </ul>
    </li>
  </ul>
</nav>
    </aside>
  
  <div class="pagination">
    
      <a href="/blog/grpc/errorhandling/" class="button left"><span>gRPC-错误处理</span></a>
    
    
      <a href="/blog/elk/kibana/" class="button right"><span>ELK-搭建Kibana</span></a>
    
  </div>
  
    <hr/>
    
  <article class="ucomments">
    <script src="https://utteranc.es/client.js"
            repo=zylhorse/zylhorse.github.io
            issue-term=title
            label=gRPC
            theme=github-light
            crossorigin="anonymous"
            async>
    </script>
  </article>



  

      <script src="/js/highlight.js"></script>
    
    <script>hljs.initHighlightingOnLoad();</script><script src="/js/bundle.min.ad234a7d27a481f0d6214513d28dbfbe759d77531bda10b3d393b978c983724c.js" integrity="sha256-rSNKfSekgfDWIUUT0o2/vnWdd1Mb2hCz05O5eMmDckw="></script>
    <script src="/js/add-on.js"></script>
  <script async src="//busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js"></script>
    </main>









  </body>
</html>
