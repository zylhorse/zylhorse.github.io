<!doctype html>
<html lang="zh-cn">
  <head>
  <meta charset="utf-8">
<title>gRPC-Introduction - zylhorse blog</title>
<meta name="viewport" content="width=device-width, initial-scale=1">


  <link rel="shortcut icon" href="/img/favicon/favicon-32x32.ico?v=1">

<meta name="generator" content="Hugo 0.93.0-DEV" /><meta itemprop="name" content="gRPC-Introduction">
<meta itemprop="description" content="gRPC 是开源的高性能RPC框架，可以运行在任何环境。它可以高效的连接数据中心或跨数据中心的服务， 支持可插拔的load balaning,tracing,health checking和authentication. 它同样适用于分布式计算的最后一英里，连接设备，手机app，浏览器到后端服务。
本章介绍gRPC 和 protocol buffers。 gRPC使用protocol buffers作为IDL(接口定义语言)和底层信息交换格式。
概述 在gRPC的架构中，client app可以像本地调用一样，直接调用一个远程server app方法，这使得创建分布式应用和服务更便捷。 与其他RPC系统相似， gRPC也是基于服务化的思想， 暴露方法，使其可以被远程调用。server端，实现这些方法并启动gRPC服务来处理client调用。 client端，stub提供与server端相同的方法，来被client端调用。
gRPC clients和servers可以在多种环境中运行和通信，并且可以用任何gRPC支持的语言编写。 例如：使用Java编写server，使用GO/Python/Ruby等编写client。 此外最新的API将有gRPC 版本号的支持。
Protocol Buffers gRPC默认使用Protocol Buffers序列化数据(当然也可以使用其它数据格式，如：JSON)。
动机 十年来，Google一直使用名为Stubby的单一通用RPC基础设施来连接数据中心或跨数据中心的微服务。Google的内部很早就采用当下流行的微服务架构。 使用统一的，跨平台的RPC基础设施，在效率、安全性、可靠性和行为分析方面进行全范围的改进，用以支撑业务的快速增长。
Stubby有许多强大的特性，但是它不基于任何标准并且与Google内部基础设施紧密耦合，因此不适合公开发布。 随着SPDY、HTTP/2和QUIC等具有相同特性的公共标准出现，包含Stubby没有提供的一些特性。很明显，是时候利用这些标准化来改造Stubby， 并扩展应用到mobile,loT和Cloud等场景。
原则和需求 Services not Objects, Messages not References 提倡在系统之间进行粗粒度信息交换的微服务设计理念，同时避免分布式对象的陷阱 和忽略网络错误
Coverage &amp; Simplicity 这个堆栈应该对所有流行的平台是可用的，并且用户可以轻松的为其选择的平台进行构建。它应该能在CPU和内存有限的设备上使用。
Free &amp; Open 使其基本功能对所有人免费使用。以开放源码的方式发布所有组件，并使用许可，应当促使而不是阻碍使用。"><meta itemprop="datePublished" content="2020-12-23T00:00:00+00:00" />
<meta itemprop="dateModified" content="2020-12-23T00:00:00+00:00" />
<meta itemprop="wordCount" content="52">
<meta itemprop="keywords" content="" /><meta property="og:title" content="gRPC-Introduction" />
<meta property="og:description" content="gRPC 是开源的高性能RPC框架，可以运行在任何环境。它可以高效的连接数据中心或跨数据中心的服务， 支持可插拔的load balaning,tracing,health checking和authentication. 它同样适用于分布式计算的最后一英里，连接设备，手机app，浏览器到后端服务。
本章介绍gRPC 和 protocol buffers。 gRPC使用protocol buffers作为IDL(接口定义语言)和底层信息交换格式。
概述 在gRPC的架构中，client app可以像本地调用一样，直接调用一个远程server app方法，这使得创建分布式应用和服务更便捷。 与其他RPC系统相似， gRPC也是基于服务化的思想， 暴露方法，使其可以被远程调用。server端，实现这些方法并启动gRPC服务来处理client调用。 client端，stub提供与server端相同的方法，来被client端调用。
gRPC clients和servers可以在多种环境中运行和通信，并且可以用任何gRPC支持的语言编写。 例如：使用Java编写server，使用GO/Python/Ruby等编写client。 此外最新的API将有gRPC 版本号的支持。
Protocol Buffers gRPC默认使用Protocol Buffers序列化数据(当然也可以使用其它数据格式，如：JSON)。
动机 十年来，Google一直使用名为Stubby的单一通用RPC基础设施来连接数据中心或跨数据中心的微服务。Google的内部很早就采用当下流行的微服务架构。 使用统一的，跨平台的RPC基础设施，在效率、安全性、可靠性和行为分析方面进行全范围的改进，用以支撑业务的快速增长。
Stubby有许多强大的特性，但是它不基于任何标准并且与Google内部基础设施紧密耦合，因此不适合公开发布。 随着SPDY、HTTP/2和QUIC等具有相同特性的公共标准出现，包含Stubby没有提供的一些特性。很明显，是时候利用这些标准化来改造Stubby， 并扩展应用到mobile,loT和Cloud等场景。
原则和需求 Services not Objects, Messages not References 提倡在系统之间进行粗粒度信息交换的微服务设计理念，同时避免分布式对象的陷阱 和忽略网络错误
Coverage &amp; Simplicity 这个堆栈应该对所有流行的平台是可用的，并且用户可以轻松的为其选择的平台进行构建。它应该能在CPU和内存有限的设备上使用。
Free &amp; Open 使其基本功能对所有人免费使用。以开放源码的方式发布所有组件，并使用许可，应当促使而不是阻碍使用。" />
<meta property="og:type" content="article" />
<meta property="og:url" content="https://zylhorse.github.io/blog/grpc/introduction/" /><meta property="article:section" content="blog" />
<meta property="article:published_time" content="2020-12-23T00:00:00+00:00" />
<meta property="article:modified_time" content="2020-12-23T00:00:00+00:00" />

<meta name="twitter:card" content="summary"/>
<meta name="twitter:title" content="gRPC-Introduction"/>
<meta name="twitter:description" content="gRPC 是开源的高性能RPC框架，可以运行在任何环境。它可以高效的连接数据中心或跨数据中心的服务， 支持可插拔的load balaning,tracing,health checking和authentication. 它同样适用于分布式计算的最后一英里，连接设备，手机app，浏览器到后端服务。
本章介绍gRPC 和 protocol buffers。 gRPC使用protocol buffers作为IDL(接口定义语言)和底层信息交换格式。
概述 在gRPC的架构中，client app可以像本地调用一样，直接调用一个远程server app方法，这使得创建分布式应用和服务更便捷。 与其他RPC系统相似， gRPC也是基于服务化的思想， 暴露方法，使其可以被远程调用。server端，实现这些方法并启动gRPC服务来处理client调用。 client端，stub提供与server端相同的方法，来被client端调用。
gRPC clients和servers可以在多种环境中运行和通信，并且可以用任何gRPC支持的语言编写。 例如：使用Java编写server，使用GO/Python/Ruby等编写client。 此外最新的API将有gRPC 版本号的支持。
Protocol Buffers gRPC默认使用Protocol Buffers序列化数据(当然也可以使用其它数据格式，如：JSON)。
动机 十年来，Google一直使用名为Stubby的单一通用RPC基础设施来连接数据中心或跨数据中心的微服务。Google的内部很早就采用当下流行的微服务架构。 使用统一的，跨平台的RPC基础设施，在效率、安全性、可靠性和行为分析方面进行全范围的改进，用以支撑业务的快速增长。
Stubby有许多强大的特性，但是它不基于任何标准并且与Google内部基础设施紧密耦合，因此不适合公开发布。 随着SPDY、HTTP/2和QUIC等具有相同特性的公共标准出现，包含Stubby没有提供的一些特性。很明显，是时候利用这些标准化来改造Stubby， 并扩展应用到mobile,loT和Cloud等场景。
原则和需求 Services not Objects, Messages not References 提倡在系统之间进行粗粒度信息交换的微服务设计理念，同时避免分布式对象的陷阱 和忽略网络错误
Coverage &amp; Simplicity 这个堆栈应该对所有流行的平台是可用的，并且用户可以轻松的为其选择的平台进行构建。它应该能在CPU和内存有限的设备上使用。
Free &amp; Open 使其基本功能对所有人免费使用。以开放源码的方式发布所有组件，并使用许可，应当促使而不是阻碍使用。"/>
<link rel="stylesheet" href="/css/bundle.min.e6b64d256349a1e498e56d1c2593ba6a2f46192823f7f0403a175b4bb8f2ee84.css" integrity="sha256-5rZNJWNJoeSY5W0cJZO6ai9GGSgj9/BAOhdbS7jy7oQ="><link rel="stylesheet" href="/css/add-on.css">
</head>

  <body>
    

<header id="site-header">
  <nav id="site-nav">
    <h1 class="nav-title">
      <a href="/" class="nav">
        
          博客
        
      </a>
    </h1>
    <menu id="site-nav-menu" class="flyout-menu menu">
      
        
          
          <a href="/" class="nav link"><i class='fas fa-home'></i> 主页</a>
        
      
        
          
          <a href="/blog/" class="nav link"><i class='far fa-newspaper'></i> 博客</a>
        
      
        
          
          <a href="/categories/" class="nav link"><i class='fas fa-sitemap'></i> 分类</a>
        
      
        
          
          <a href="/tags/" class="nav link"><i class='fas fas fa-tags'></i> 标签</a>
        
      
        
          
          <a href="/about/" class="nav link"><i class='far fa-id-card'></i> 关于</a>
        
      
      
      <a href="#search-input" class="nav link search-toggle"><i class="fas fa-search">&nbsp;</i>Search</a>
    </menu>
    <a href="#search-input" class="nav search-toggle"><i class="fas fa-search fa-2x">&nbsp;</i></a>
    
    
    <a href="#site-nav" class="nav nav-toggle"><i class="fas fa-bars fa-2x"></i></a>
  </nav>
  <menu id="search" class="menu"><input id="search-input" class="search-input menu"></input><div id="search-results" class="search-results menu"></div></menu>
  
  
</header>

    <main id="site-main">
      
  <article class="post">
    <header>
  <div class="title">
    
      <h2><a href="/blog/grpc/introduction/">gRPC-Introduction</a></h2>
    
    
  </div>
</header>
    <div class="meta">
    <p title="Created" class="fas fa-calendar-plus">
        <time datetime="2020-12-23 00:00:00 &#43;0000 UTC">2020-12-23</time>
    </p>
    
        <p title="Author" class="fas fa-user">zylhorse
        </p>
    
    
        <p title="ReadingTime" class="fas fa-stopwatch">
            &lt;no value&gt;分钟
        </p>
    
    
        <p id="busuanzi_container_page_pv">
        <p id="busuanzi_value_page_pv" title="Vistors" class="fas fa-eye">
        </p>
        </p>
    
</div>
    <div class="content">
      
      <p>gRPC 是开源的高性能RPC框架，可以运行在任何环境。它可以高效的连接数据中心或跨数据中心的服务， 
支持可插拔的<code>load balaning</code>,<code>tracing</code>,<code>health checking</code>和<code>authentication</code>.
它同样适用于分布式计算的最后一英里，连接设备，手机app，浏览器到后端服务。</p>
<p>本章介绍gRPC 和 protocol buffers。 gRPC使用protocol buffers作为IDL(接口定义语言)和底层信息交换格式。</p>
<h2 id="概述">概述</h2>
<p>在gRPC的架构中，client app可以像本地调用一样，直接调用一个远程server app方法，这使得创建分布式应用和服务更便捷。
与其他RPC系统相似， gRPC也是基于服务化的思想， 暴露方法，使其可以被远程调用。server端，实现这些方法并启动gRPC服务来处理client调用。
client端，stub提供与server端相同的方法，来被client端调用。<br>
<img src="/img/grpc/server-client.svg" alt="gRPC server client"></p>
<p>gRPC clients和servers可以在多种环境中运行和通信，并且可以用任何gRPC支持的语言编写。 例如：使用Java编写server，使用GO/Python/Ruby等编写client。
<strong>此外最新的API将有gRPC 版本号的支持。</strong></p>
<h3 id="protocol-buffers">Protocol Buffers</h3>
<p>gRPC默认使用<a href="/blog/data-structure/protocol-buffers/instroduction">Protocol Buffers</a>序列化数据(当然也可以使用其它数据格式，如：JSON)。</p>
<h2 id="动机">动机</h2>
<p>十年来，Google一直使用名为<code>Stubby</code>的单一通用RPC基础设施来连接数据中心或跨数据中心的微服务。Google的内部很早就采用当下流行的微服务架构。
使用统一的，跨平台的RPC基础设施，在效率、安全性、可靠性和行为分析方面进行全范围的改进，用以支撑业务的快速增长。<br>
<code>Stubby</code>有许多强大的特性，但是它不基于任何标准并且与Google内部基础设施紧密耦合，因此不适合公开发布。
随着<code>SPDY</code>、<code>HTTP/2</code>和<code>QUIC</code>等具有相同特性的公共标准出现，包含<code>Stubby</code>没有提供的一些特性。很明显，是时候利用这些标准化来改造<code>Stubby</code>，
并扩展应用到<code>mobile</code>,<code>loT</code>和<code>Cloud</code>等场景。</p>
<h2 id="原则和需求">原则和需求</h2>
<p><strong>Services not Objects, Messages not References</strong>
提倡在系统之间进行粗粒度信息交换的微服务设计理念，同时避免<a href="https://martinfowler.com/articles/distributed-objects-microservices.html">分布式对象的陷阱</a>
和<a href="https://en.wikipedia.org/wiki/Fallacies_of_distributed_computing">忽略网络错误</a></p>
<p><strong>Coverage &amp; Simplicity</strong>
这个堆栈应该对所有流行的平台是可用的，并且用户可以轻松的为其选择的平台进行构建。它应该能在CPU和内存有限的设备上使用。</p>
<p><strong>Free &amp; Open</strong>
使其基本功能对所有人免费使用。以开放源码的方式发布所有组件，并使用许可，应当促使而不是阻碍使用。</p>

      
    <h2>参考</h2>
    <ul>
        
            
                <li><a target="_blank" href="https://grpc.io/docs/what-is-grpc/introduction/">Introduction to gRPC</a></li>
            
        
            
                <li><a target="_blank" href="https://github.com/grpc/grpc/tree/master/doc">gRPC github doc</a></li>
            
        
            
                <li><a target="_blank" href="https://grpc.io/blog/principles/">gRPC principies</a></li>
            
        
    </ul>

    </div>
    <footer>
      <div class="stats">
  
    <ul class="categories">
      
        
          <li><a class="article-terms-link" href="/categories/grpc/">gRPC</a></li>
        
      
    </ul>
  
  
    <ul class="tags">
      <li>None</li>
    </ul>
  
</div>

    </footer>
  </article>
  
    <aside id="toc">
      <div class="toc-title">目录</div>
      <nav id="TableOfContents">
  <ul>
    <li><a href="#概述">概述</a>
      <ul>
        <li><a href="#protocol-buffers">Protocol Buffers</a></li>
      </ul>
    </li>
    <li><a href="#动机">动机</a></li>
    <li><a href="#原则和需求">原则和需求</a></li>
  </ul>
</nav>
    </aside>
  
  <div class="pagination">
    
      <a href="/blog/grpc/protocol-http2/" class="button left"><span>gRPC over HTTP2</span></a>
    
    
      <a href="/blog/grpc/platform/" class="button right"><span>gRPC-platform</span></a>
    
  </div>
  
    <hr/>
    
  <article class="ucomments">
    <script src="https://utteranc.es/client.js"
            repo=zylhorse/zylhorse.github.io
            issue-term=title
            label=gRPC
            theme=github-light
            crossorigin="anonymous"
            async>
    </script>
  </article>



  

      <script src="/js/highlight.js"></script>
    
    <script>hljs.initHighlightingOnLoad();</script><script src="/js/bundle.min.ad234a7d27a481f0d6214513d28dbfbe759d77531bda10b3d393b978c983724c.js" integrity="sha256-rSNKfSekgfDWIUUT0o2/vnWdd1Mb2hCz05O5eMmDckw="></script>
    <script src="/js/add-on.js"></script>
  <script async src="//busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js"></script>
    </main>









  </body>
</html>
